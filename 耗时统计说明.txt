═══════════════════════════════════════════════════════════════════════════════
                        对话历史工具 - 总耗时统计功能
═══════════════════════════════════════════════════════════════════════════════

版本 3.1 新增：智能总耗时计算，自动去重，精准统计！

───────────────────────────────────────────────────────────────────────────────
⏱️  功能说明
───────────────────────────────────────────────────────────────────────────────

## 什么是总耗时？

总耗时 = 助手实际工作时间
       = 所有「用户消息 → 助手消息」的时间间隔累加
       = 不含等待用户输入的时间

## 计算方法

1. 加载所有对话消息
2. **自动去重**（避免重复计算）
3. 按时间排序
4. 遍历所有消息对：
   - 如果是 用户消息 → 助手消息
   - 计算时间差并累加
   - 过滤异常值（>1小时的响应）
5. 输出总耗时和平均响应时间

───────────────────────────────────────────────────────────────────────────────
📊 统计数据解读
───────────────────────────────────────────────────────────────────────────────

## 示例输出

```
⏱️  总耗时统计:
   助手处理总时长: 2小时 5分钟 54秒  ← 实际工作时间
   平均响应时间: 4秒                 ← 每次回复平均耗时
   工作时间占比: 1.3%                ← 工作时间/总跨度
```

## 各项指标含义

### 1. 助手处理总时长
**含义**: 助手实际工作的总时间
**计算**: 所有有效响应时间的累加
**你的数据**: 2小时 5分钟 54秒（约7554秒）

**意味着什么？**
• 在过去7天里，Claude 实际工作了约2小时
• 完成了 1,734 次助手回复
• 处理了你提出的 976 个问题

### 2. 平均响应时间
**含义**: 每次回复平均需要的时间
**计算**: 总耗时 ÷ 助手消息数
**你的数据**: 4秒

**意味着什么？**
• Claude 平均4秒就能给出回复
• 包括思考、工具调用、代码编写等
• 响应速度很快！

### 3. 工作时间占比
**含义**: 实际工作时间占总时间跨度的百分比
**计算**: (总耗时 ÷ 总跨度) × 100%
**你的数据**: 1.3%

**意味着什么？**
• 总跨度7天 = 168小时
• 实际工作2小时
• 占比 = 2/168 = 1.2%
• 说明大部分时间在等待你的输入（这是正常的）

───────────────────────────────────────────────────────────────────────────────
🔍 详细计算示例
───────────────────────────────────────────────────────────────────────────────

## 计算过程演示

```
时间线：
10:00:00  👤 用户: 请帮我写个函数
10:00:05  🤖 助手: 好的，我来写...      ← 耗时 5秒
10:00:20  👤 用户: 再优化一下
10:00:28  🤖 助手: 已优化完成...        ← 耗时 8秒
10:05:00  👤 用户: 谢谢

总耗时 = 5秒 + 8秒 = 13秒
等待用户时间 = 不计入（10:00:05 → 10:00:20 = 15秒）
总跨度 = 10:00:00 → 10:05:00 = 5分钟
工作占比 = 13秒 / 300秒 = 4.3%
```

## 过滤规则

**过滤超过1小时的响应**
```
09:00:00  👤 用户: 早上好
12:30:00  🤖 助手: 你好          ← 3.5小时，异常！
                                   （可能是吃饭休息了）
                                   → 不计入总耗时
```

**为什么过滤？**
• 超过1小时的响应通常不是连续工作
• 可能是中间休息、吃饭、睡觉等
• 过滤后数据更准确

───────────────────────────────────────────────────────────────────────────────
📈 你的对话数据分析
───────────────────────────────────────────────────────────────────────────────

基于当前数据（去重后）：

## 消息统计
• 原始消息: 5,118 条
• 去重后: 2,710 条（移除47%重复）
• 用户消息: 976 条
• 助手消息: 1,734 条

## 时间统计
• 总跨度: 7天（2025-12-04 至 2025-12-11）
• 工作时长: 2小时 5分钟 54秒
• 平均响应: 4秒
• 工作占比: 1.3%

## 效率分析
• 每天平均: 约18分钟工作时间
• 每条回复: 平均4秒
• 响应比例: 1,734回复 / 976问题 ≈ 1.78
  （说明有些问题需要多次交互）

## 活跃度分析
• 最活跃: 2025-12-05（1,930条消息）
• 次活跃: 2025-12-08（1,414条消息）
• 最近: 2025-12-11（43条消息）

───────────────────────────────────────────────────────────────────────────────
🎯 使用建议
───────────────────────────────────────────────────────────────────────────────

## 场景 1: 查看工作效率

```bash
python3 chat_stats.py
```

重点关注：
• 平均响应时间：是否在可接受范围
• 工作时间占比：了解实际使用情况
• 每日消息数：找出高效工作日

## 场景 2: 对比不同时期

```bash
# 导出不同日期的统计
python3 chat_stats.py > stats_2025_12_11.txt
```

对比发现：
• 哪天最高效？
• 平均响应时间是否稳定？
• 工作时长趋势如何？

## 场景 3: 评估项目进度

工作时长可以作为项目进度的参考：
• 总共投入多少时间？
• 平均每天工作多久？
• 是否达到预期？

───────────────────────────────────────────────────────────────────────────────
💡 注意事项
───────────────────────────────────────────────────────────────────────────────

## 去重的重要性

**不去重的问题**：
```
重复消息数: 2,408 条（47%）
如果不去重: 耗时会被重复计算
结果偏差: 可能翻倍！
```

**去重的好处**：
✓ 避免重复计算
✓ 数据更准确
✓ 反映真实工作时间

## 过滤异常值

**为什么要过滤？**
• 超过1小时的响应通常不连续
• 避免异常数据污染统计
• 更真实反映工作时间

**如何调整？**
修改 chat_stats.py 中的阈值：
```python
# 当前: 过滤超过1小时的
if timedelta(0) < time_diff < timedelta(hours=1):

# 改为2小时:
if timedelta(0) < time_diff < timedelta(hours=2):
```

## 时区问题

**自动处理**：
• 代码会自动处理时区（.replace('Z', '+00:00')）
• 所有时间统一转换为本地时间
• 无需手动调整

───────────────────────────────────────────────────────────────────────────────
🔧 技术实现
───────────────────────────────────────────────────────────────────────────────

## 核心算法

```python
def calculate_total_time(messages):
    total_time = timedelta()

    for i in range(len(messages) - 1):
        current = messages[i]
        next = messages[i + 1]

        # 只计算 用户 → 助手
        if current['type'] == 'user' and next['type'] == 'assistant':
            time_diff = next['time'] - current['time']

            # 过滤异常值
            if 0 < time_diff < 1_hour:
                total_time += time_diff

    return total_time
```

## 去重算法

```python
def deduplicate_messages(messages):
    seen = set()
    unique = []

    for msg in messages:
        # 使用UUID或时间戳+内容作为标识
        identifier = msg['uuid'] or f"{msg['time']}_{msg['content'][:100]}"

        if identifier not in seen:
            seen.add(identifier)
            unique.append(msg)

    return unique
```

───────────────────────────────────────────────────────────────────────────────
📊 对比：去重前 vs 去重后
───────────────────────────────────────────────────────────────────────────────

| 项目 | 去重前 | 去重后 | 差异 |
|------|--------|--------|------|
| 总消息数 | 5,118条 | 2,710条 | -47% |
| 助手消息 | ~3,000条 | 1,734条 | -42% |
| 预估耗时 | ~4小时 | 2小时6分 | -48% |
| 数据准确性 | ⚠️ 重复计算 | ✓ 准确 | 重要！ |

**结论**：去重非常重要！不去重会导致耗时翻倍。

───────────────────────────────────────────────────────────────────────────────
❓ 常见问题
───────────────────────────────────────────────────────────────────────────────

Q1: 为什么工作时间占比这么低（1.3%）？
A: 这是正常的！
   • 总跨度包括睡觉、吃饭、休息时间
   • 实际工作时间只有2小时
   • 大部分时间在等待你的输入
   • 这反映了真实的使用模式

Q2: 平均响应时间4秒，是快还是慢？
A: 非常快！
   • 包括了思考、工具调用、代码编写
   • 考虑到任务复杂度，4秒很快
   • 这是平均值，简单问题更快

Q3: 如何提高工作效率？
A: 几个建议：
   • 问题尽量具体明确
   • 一次性提供完整信息
   • 减少来回确认的次数
   • 使用 --deduplicate 避免重复

Q4: 总耗时包括什么？
A: 只包括助手实际处理时间：
   ✓ 思考时间
   ✓ 工具调用时间
   ✓ 代码编写时间
   ✓ 文件读写时间
   ✗ 不包括等待用户输入的时间

Q5: 去重会影响耗时计算吗？
A: 不会！去重是为了避免重复计算：
   • 先去重，再计算耗时
   • 确保每条消息只计算一次
   • 数据更准确

───────────────────────────────────────────────────────────────────────────────
🌟 总结
───────────────────────────────────────────────────────────────────────────────

核心功能：
✓ 自动计算助手总工作时间
✓ 自动去重，避免重复计算
✓ 过滤异常值，数据更准确
✓ 显示平均响应时间和工作占比

使用方法：
python3 chat_stats.py

输出内容：
• 助手处理总时长
• 平均响应时间
• 工作时间占比
• 去重统计
• 每日消息数

你的数据：
• 总工作时长: 2小时 6分钟
• 平均响应: 4秒
• 完成回复: 1,734 次
• 效率: 很高！

═══════════════════════════════════════════════════════════════════════════════
